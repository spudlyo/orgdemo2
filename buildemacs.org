#+TITLE: Building Emacs from Source
#+SUBTITLE: An essential guide
#+AUTHOR: Mike Hamrick
#+EMAIL: mikeh@muppetlabs.com
#+OPTIONS: ^:nil date:t email:t num:2 tags:nil toc:nil
#+STARTUP: content
#+SETUPFILE: latex.setup
#+INCLUDE: macros.setup
#+EXCLUDE_TAGS: noexport redhat
#+PROPERTY: header-args :noweb yes :exports both :cache yes
#+PROPERTY: header-args:bash :results output :dir ~/src/emacs

#+begin_export latex
  \begin{center}
     \includesvg[width=10cm]{logo.svg}
  \end{center}
  \clearpage \tableofcontents \clearpage
#+end_export

* README                                                           :noexport:
:PROPERTIES:
:VISIBILITY: all
:END:
This file is a literate Org-mode document. It is intended to be "run" by GNU Emacs 27.1 or higher. This document can
execute =bash= shell code in order to demonstrate how to create install packages and build Emacs. Out of the box,
however, all exported =bash= code blocks include cached results from a previous run. This means no bash code blocks will
be executed on your system. If Emacs ever asks you if you want to execute a =bash= source code block, it means something
is no longer cached and you should be wary of saying "yes" unless you know what you're doing.

This Org-mode document you're currently viewing can be seen as "source code" that produces a document that explains how
to build Emacs from scratch on both RedHat and Debian based systems. The hope is that this Org-mode source code is
useful for understanding how to create nice-looking literate Org-mode documents. I hope some people might enjoy the
resulting document that it produces, but ultimately it's not important for the purposes of understanding how Org-mode
works.

** Operating System Prerequisites
This document is intended to be "run" on a GNU/Linux system. It has been tested on both RedHat based systems (Fedora
Server 38) and Debian based systems (Ubuntu Server 22.04).

** Choosing which version of the document to export
<<doc version>>
The document will will differ slightly depending on which version of the document you chose to export. By default, if
this document is not altered in any way, you will get the Debian/Ubuntu version of the document. If you wish to export
the RedHat/Fedora version of the document, you will first need to:

- change the "#+EXCLUDE_TAGS:" line at the top of the document to "noexport debian";
- change the ":prefix:" property in section [[constants]] to "rh_".

You can hit =C-c C-c= on the Emacs Lisp block below to do just that.

#+caption: Configure this document using Emacs Lisp for RedHat
#+begin_src elisp :eval never-export :var os="redhat"
(let* ((redhat-p    (string= os "redhat"))
       (exclude_tag (if redhat-p "debian" "redhat"))
       (prefix      (if redhat-p "rh_" "deb_")))
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward "^#\\+EXCLUDE_TAGS:.*" nil t)
      (replace-match (concat "#+EXCLUDE_TAGS: noexport " exclude_tag)))
    (when (re-search-forward "^:prefix:.*" nil t)
      (replace-match (concat ":prefix: " prefix)))))
#+end_src

#+RESULTS[68bd323dcc138a1614b613017ea701a1bdb005d8]:

*** Using the 'sudo' command
Many of the =bash= code blocks in this document use the =sudo= command in order to execute shell commands as a
privileged user. By default, =sudo= will prompt you for a password, which will cause issues when running the commands in
this document, since we're not running in an interactive mode. In order for your local user to run privileged commands
/without/ a password, you'll need to make a change to the =/etc/sudoers= file using the =sudo visudo= command, which
will fire up =$EDITOR= for you to edit =/etc/sudoers=.

You should see a section in the file that allows users of a specific group (in this case the =sudo= group) to execute
any command. On RedHat based GNU/Linux systems the group is called =wheel= rather than =sudo=.

#+caption: Relevant section from /etc/sudoers on Ubuntu
#+begin_example
# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
#+end_example

When you edit it, you'll want to change it to look like this:

#+caption: Updated section from /etc/sudoers on Ubuntu
#+begin_example
# Allow members of group sudo to execute any command
%sudo   ALL=(ALL) NOPASSWD: ALL
#+end_example

** Emacs Prerequisites
This document has been tested on Emacs 27.1, Emacs 28.3, and Emacs 29.1. It may work on earlier versions of Emacs if
you've installed Org mode version 9.3 or above. You should be able to export this document to Plain Text or PDF formats
without installing any additional Emacs packages, it should work with Vanilla Emacs. You also don't need the GUI version
of Emacs; it should work fine in the Terminal.

On Ubuntu 22.04 you can install Emacs 27.1 by running: =sudo apt install emacs-nox=. On Fedora 38 you can install
Emacs 28.3 using =sudo dnf install emacs-nox=. Ideally, you will be viewing this document inside GNU Emacs.

** LaTeX Prerequisites
If you want to export this document to LaTeX or PDF you'll need to install some some additional OS packages.

| Software       | Debian Package       | RedHat Package       |
|----------------+----------------------+----------------------|
| TeX Live       | texlive-latex-extra  | texlive-latex        |
| xelatex        | texlive-xetex        | texlive-xetex        |
| pdflatex       | texlive-extra-utils  | texlive-latex        |
| latexmk        | latexmk              | latexmk              |
| inkscape       | inkscape             | inkscape             |
| JetBrains Mono | fonts-jetbrains-mono | jetbrains-mono-fonts |
| Inter          | fonts-inter          | rsms-inter-fonts     |

If you can run 'sudo' without needing a password you can hit =C-c C-c= on the block below to install the necessary
Debian packages to generate LaTeX PDF output. The block below that is for RedHat based systems.

*NOTE:* This can take several minutes to run, during which time Emacs may appear to be locked up as this work is /not/ done
asynchronously. This is around 1.5GB of packages, so make sure you have the space available.

#+caption: Install LaTeX Prerequisites on Debian based systems
#+name: deb_install_latex
#+begin_src bash :eval never-export :results output replace :dir ~/
  sudo apt-get install -qq \
       texlive-latex-extra \
       texlive-extra-utils \
       texlive-xetex \
       latexmk \
       inkscape \
       fonts-jetbrains-mono \
       fonts-inter > /dev/null 2>&1 && echo Success!
#+end_src

#+caption: Install LaTeX Prerequisites on RedHat based systems
#+name: rh_install_latex
#+begin_src bash :eval never-export :results output replace :dir ~/
  sudo dnf install -y \
       texlive-latex \
       texlive-xetex \
       texlive-wrapfig \
       texlive-ulem \
       texlive-capt-of \
       texlive-svg \
       texlive-trimspaces \
       texlive-parskip \
       latexmk \
       inkscape \
       jetbrains-mono-fonts \
       texlive-inter > /dev/null 2>&1 && echo Success!
#+end_src

** Executing the code found in this document
If you do want to actually execute the code in this document, you have a couple of options. You can navigate to the [[main
document]] and manually press =C-c C-c= on each code block. This will require you to invalidate the cache first, which you
can do by modifying the value of the checksum on the =+RESULTS[checksum]:= block. I like this approach because it gives you
precise control of when the blocks are executed, and lets you observe each result before moving to the next block.

Alternately, you can change the default header arg from =:cache yes= to =:cache no= at the top of the document. Once you
do this, when you export the document it should run all the source code blocks. Annoyingly,  it will prompt you for
confirmation on each =bash= code block. If you'd like to change this, you can hit =C-c C-c= on the block below which
will cause Org-mode to never confirm the execution of any source block.

# You know what you're doing, right? Right!?
#+name: no_babel_confirm
#+begin_src elisp :eval never-export
(setq org-confirm-babel-evaluate nil)
#+end_src

*NOTE*: Building Emacs can take 10-15 minutes or more on a slow machine. This means Emacs can be spinning its wheels for
a while during the export process, as it cranks through the source blocks in the document. This is not asynchronous, and
Emacs will appear to be locked up during this time.

* Properties as Constants                                          :noexport:
:PROPERTIES:
:prefix: deb_
:rh_user: a Fedora 38 user
:deb_user: an Ubuntu 22.04 user
:deb_osver: Ubuntu Server 22.04
:rh_osver: Fedora Server 38
:rh_install: sudo dnf install -y
:deb_install: sudo apt-get install -qq
:deb_gnutls: libgnutls28-dev
:rh_gnutls: gnutls-devel
:deb_ncurses: libncurses-dev
:rh_ncurses: ncurses-devel
:END:
<<constants>>
The properties above define all the constants we're using throughout this document. By default, when you
run this document it will describe how to build GNU Emacs under a Debian based system. If you'd like to change this,
there are instructions on how to do so in the [[doc version]] section.

* Code                                                             :noexport:
What follows is code that will be used throughout the document.

#+name: lsplit
#+begin_src elisp :results value :exports none :var line="foo bar\nbaz" :cache yes
(car (split-string line))
#+end_src

#+name: get_prop
#+begin_src elisp :results value :exports none :var prop="test"
(let ((ret (org-property-values prop))
      (prefix (org-property-values "prefix")))
  (if ret
      (car ret)
    (when prefix
      (car (org-property-values (concat (car prefix) prop))))))
#+end_src

#+name: strip
#+begin_src elisp :results value raw :exports none :var line="  foo  "
(string-trim line)
#+end_src

The following function is run when the document is loaded by Emacs. You have to OK this first. Most of what this code
does is make it so every =#+begin_example= and =#+end_example= block is rendered in LaTeX with a box around it. It's a lot
of effort for pretty boxes, but it's worth it. Also, if you're not using a custom Emacs theme I load the wonderful
=leuven= theme which comes with Emacs and makes Org documents look amazing. Sorry, not sorry.

#+NAME: startup
#+begin_src emacs-lisp :eval never-export :cache no :exports none
(require 'ox)

(if (null custom-enabled-themes)
    (load-theme 'leuven))

(defun my-latex-export-example-blocks (text backend info)
  "Export example blocks as smallbox env."
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      ;; replace verbatim env with smallbox
      (goto-char (point-min))
      (replace-string "\\begin{verbatim}" "\\begin{smallbox}")
      (replace-string "\\end{verbatim}" "\\end{smallbox}")
      (buffer-substring-no-properties (point-min) (point-max)))))

(make-local-variable 'org-export-filter-example-block-functions)
(add-to-list 'org-export-filter-example-block-functions
             'my-latex-export-example-blocks)
#+end_src

#+RESULTS: startup
| my-latex-export-example-blocks |

* Introduction
In this document we're going to demonstrate how you, {{{pr(user)}}}, can download and build the source code for GNU
Emacs. The goal is to walk through each step of the process, and explain things as we go. By default, most systems do
not have the necessary software components installed that are required to build GNU Emacs from source, so we'll also be
installing a lot of software on your computer. You'll need =sudo= access for this, and this document assumes that your
local user can run =sudo= without a password.

Much of this document is going to involve trying to run the Emacs =./configure= script, having something fail, resolving
some missing software dependency, and then trying again until we finally have a successful build. It's a bit of an
iterative process.

* Obtaining the Source Code
:PROPERTIES:
:header-args:       :noweb yes :exports both :cache yes
:header-args:bash:  :results output :dir ~/src/emacs
:END:
In this chapter, I'll demonstrate how to download the Emacs source code using =git= and how to set your view of the code
to a specific tagged release of GNU Emacs.

** Installing Development Tools                                      :redhat:
By default, on the {{{pr(osver)}}} systems I tested on, the =git= program is not installed, so the first thing we'll do
is install it using the =dnf= package manager, along with some other development tools. Here we provide the =-y= option
so =dnf= doesn't ask us any questions, and we'll redirect =stdout= and =stderr= to =/dev/null= to suppress the copious
amount of output that =dnf= spits out.

#+caption: Install the the Development Tools group of packages
#+name: rh_install_devtools
#+begin_src bash :dir ~/
  sudo dnf groupinstall -y --quiet "Development Tools" >/dev/null 2>&1
#+end_src

#+RESULTS[e47ce0ed8dba29e94038f234de67776a00b6ed1c]: rh_install_devtools

** Creating a source directory

Let's kick things off by creating a =~/src= directory beneath our home directory where all our source code is going to
live. We'll also change our current working directory to this directory. This helps keep things tidy.

#+caption: Create and cd to our source directory
#+name: create_src_dir
#+begin_src bash :dir ~/
  mkdir -p ~/src; cd ~/src
#+end_src

#+RESULTS[1e510283b8ed64f004699221b06b8f48feef95c8]: create_src_dir

** Cloning the Repo
The next thing we'll want to do is clone the Emacs repository from /Savannah/, the software forge hosted by the Free
Software Foundation. This will be a full clone, complete with history, branches, and tags, so it can take a few minutes
to complete. We'll provide the =--quiet= option to =git= to tell it not to report its progress to the screen.

#+caption: Clone the Emacs git repository from Savannah
#+name: clone_repo
#+begin_src bash :dir ~/src
  git clone --quiet https://git.savannah.gnu.org/git/emacs.git
  cd emacs
  #+end_src

  #+RESULTS[8c1c3caeaa94401e641350ecb1d16751ba044fdf]: clone_repo

** Digging into the tags
<<tags>>
Now that we've cloned the repository and set our current working directory to =~/src/emacs=, let's take a look at some
tags. Emacs uses =git= tags to capture a point in the commit history that marks the release of a specific version. We can
run =git tag= to list all the available tags.

#+caption: How many tags are there?
#+name: num_tags
#+begin_src bash
  git tag | wc -l
  #+end_src

  #+RESULTS[bff0bbcb583233629cc6dabd0d6296379d4f1cc8]: num_tags
  #+begin_example
  183
  #+end_example

Wow, {{{sr(num_tags)}}} tags is a lot! We can narrow it down a bit by listing just the tags for Emacs 29. We'll use the
=git tag= command with the =--list= argument (using the shell wildcard syntax), as well as specifying the =--sort=
option, to sort the tags by when the tag object in the database was created. We'll also specify the =-n= argument to
print a single line of annotation for the tag.

#+caption: List all the tags for Emacs version 29, sorted by date in descending order
#+name: sorted_tags
#+begin_src bash :cache yes
  git tag --list 'emacs-29.*' --sort=-taggerdate -n1
#+end_src

#+RESULTS[fa306c1f9b3f73ea2220e75183509c97a622ef59]: sorted_tags
#+begin_example
emacs-29.1.90   Emacs 29.1.90 pretest
emacs-29.1      Emacs 29.1
emacs-29.1-rc1  Emacs 29.1 RC1
emacs-29.0.92   Emacs 29.0.92
emacs-29.0.91   Emacs 29.0.91 pretest
emacs-29.0.90   Emacs 29.0.90 pretest
#+end_example

#+name: emacs_tag
#+begin_src elisp :results value :exports none :var text=sorted_tags :cache yes
(with-temp-buffer
  (insert text) (beginning-of-buffer)
  (if (re-search-forward "\\(\\S-+\\)" nil t)
      (match-string 1)
    nil))
#+end_src

You might get a slightly different list when you run the command, but as of this writing these are all the tagged
releases of Emacs 29. We'll be working with the version tagged {{{srv(emacs_tag)}}}, as that's the most recent.

** Creating the branch

Now that we've figured out which version tag we're going to want to use as the base for the version of Emacs that we're
building, it's time to create a branch associated with that tag. Because we just cloned the repository, we're currently
on at the default branch.

#+caption: Ask git the name of our current branch
#+name: git_branch
#+begin_src bash
  git branch --show-current
#+end_src

#+RESULTS[853780933fd9180c73d0352492b67618b70a2c0c]: git_branch
#+begin_example
master
#+end_example

For our purposes, we don't want to build Emacs from the {{{srv(git_branch)}}} branch. Instead, let's create a branch
that points to the same commit as the {{{srv(emacs_tag)}}} tag that we identified in section [[tags]].

#+caption: Create a branch that points to a specific tag
#+name: create_branch
#+begin_src bash
  git checkout -b mybranch tags/<<emacs_tag()>> 2>&1
#+end_src

#+RESULTS[7f3bf7669e1efbb91dd5fd9cfedda00ebbecfe75]: create_branch
#+begin_example
Switched to a new branch 'mybranch'
#+end_example

We're good to go! We've created our branch at our tagged location, so now we can start working on building the program.

* Creating the configure script
If you've ever built an old-school UNIX program from source, you've probably run a =./configure= script. This script
tests specific details about the environment it's running under in order to inform the build process how it should
interact with the code in a way that's compatible with the operating system and libraries that exist on the
system. Normally when building trivial programs, you can run a familiar incantation like =./configure && make && make
install= and you're good to go.

Let's see if we can find a suitable =./configure= script in the Emacs repository.

#+caption: Look for the configure script
#+name: where_configure
#+begin_src bash
  ls configure*
#+end_src

#+RESULTS[b55a980ceb18f9d71f4108e331b7f52e0340597b]: where_configure
#+begin_example
configure.ac
#+end_example

Looks like there isn't a =./configure= script for us to run, so we'll have to generate one. The =./configure= script is
generated using a tool called =autoconf= which is part of the GNU Build System, also known as Autotools. The =autoconf=
tool reads the =./configure.ac= file we saw above and uses that to generate the =./configure= script we'll ultimately
run.

** Running the autogen.sh script
There is a script called =autogen.sh= that drives this process. It also modifies your cloned =.git/config= configuration
file, as well as adding various hooks in =.git/hooks= that are suitable for Emacs development. Let's run the script and
take a look at the first few lines of the output. We'll run =autogen.sh= with the =autoconf= argument to tell it to only
generate the =./configure= script, to to leave our git configuration untouched.

#+caption: Run the autogen.sh script and show a bit of the output
#+name: autogen
#+begin_src bash
  ./autogen.sh autoconf | head -n3
#+end_src

#+RESULTS[32d8dc5d0ad6bf23e070bc6beea8cd130026f7e5]: autogen
#+begin_example
Checking whether you have the necessary tools...
(Read INSTALL.REPO for more details on building Emacs)
Checking for autoconf (need at least version 2.65) ... missing
#+end_example

It looks like we're going to need to install =autoconf= before this is going to work for us.

*NOTE*: When we're installing software in this document, we'll often suppress the output like we do below by redirecting
=stderr= and =stdout= to =/dev/null=. This is because the output is often quite long and irrelevant to the task at hand.

#+caption: Install autoconf and send the output to /dev/null
#+name: install_autoconf
#+begin_src bash
  <<get_prop("install")>> autoconf >/dev/null 2>&1
#+end_src

#+RESULTS[a8fa3622ef519098920b84ca052a3c03e4e8cf35]: install_autoconf

Now if we run the =autogen.sh= script again, it should generate our =./configure= script. This time we'll run it with the
=--no-check= argument, because we've satisfied the autoconf dependency.

#+caption: Second time is a charm!
#+name: autogen_redux
#+begin_src bash
  ./autogen.sh --no-check autoconf
#+end_src

#+RESULTS[e9357d1355a2c1711fa9956e8a2c51ea486a4d03]: autogen_redux
#+begin_example
Building aclocal.m4 ...
Running 'autoreconf -fi -I m4' ...
You can now run './autogen.sh git'.
#+end_example

If if we look for the =./configure= script again, it should be there!

#+caption: Look for the configure script again
#+name: where_configure_redux
#+begin_src bash
  stat --format "%s %n" ./configure
#+end_src

#+RESULTS[9d47e75f7838fcdaed93775e524b776ac8762b7c]: where_configure_redux
#+begin_example
1189578 ./configure
#+end_example

Wow, that is one huge shell script! When was the last time /you/ wrote a shell script that was
call_lsplit(where_configure_redux) bytes long?!

* Configuring the build process
#+name: tag_dir
#+begin_src elisp :results value :exports none :var text=emacs_tag :cache yes
(concat "$HOME/" text)
#+end_src

In this section we're going to run the =./configure= script to kick off the configuration process. We're not going to
specify which Emacs features we want to enable, or get into any specifics of how it is built. Instead we're going to see
what it takes to build a minimal version of Emacs.

** The prefix argument
One argument we /will/ be providing to the configure script will be the =--prefix= option. This tells the script the
base directory of where all the files should be installed. By default, when we later run =make install=, there will be a
number of directories created for both architecture-dependent and -independent files like binaries, libraries, Emacs
Lisp code, and documentation. All of of these directories will be created beneath the directory we specify with our
=--prefix= argument. We'll use {{{s(tag_dir)}}} as our prefix directory, this way we can potentially build and install
multiple tagged versions of Emacs without conflict.

** Installing the build essential meta-package                       :debian:
Let's run =./configure= and see what happens. We'll provide our =--prefix= argument, and we'll also redirect =stderr= to
=stdout= so all the output goes to the same place. Finally we'll take advantage of the =bash= logical OR (=||=)
short-circuit to echo a message if =./configure= returns a non-zero exit code.

#+caption: Our first attempt at running configure
#+name: configure_no_make
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 || echo Configure failed!
#+end_src

#+RESULTS[89c7b86937fc395d7e266087ed1a997523114667]: configure_no_make
#+begin_example
checking for xcrun... no
checking for GNU Make...
configure: error: Building Emacs requires GNU Make, at least version 3.81.
If you have it installed under another name, configure with 'MAKE=...'.
For example, run './configure MAKE=gnu-make'.
Configure failed!
#+end_example

Oops, looks like we don't have GNU Make installed. By default on {{{pr(osver)}}} there aren't any development or build
tools installed. We can solve this problem by installing the =build-essential= meta-package, which installs a C/C++
compiler, GNU Make, and some libraries. We'll also take this opportunity to install the =pkg-config= utility which is a
helper tool that lets you quickly identify where existing libraries are installed and which compiler flags to use.

#+caption: Install the build-essential meta-package and send the output to /dev/null
#+name: install_build_essential
#+begin_src bash
  sudo apt-get install -qq build-essential pkg-config >/dev/null 2>&1
#+end_src

#+RESULTS[5710ea359b6016e54699deb1de9754ea07dd6193]: install_build_essential

** Installing GNU Texinfo
Let's run =./configure= and see what happens. We'll provide our =--prefix= option and redirect =stderr= to =stdout= so
all the output goes to the same place. Since the =./configure= script can output quite a large volume of text to the
terminal we'll also pipe the output into =tail -n5= to just see the last handful of lines. Finally we'll utilize the
=bash= array variable =$PIPESTATUS= (which holds the exit statuses of each command executed in the most recent pipeline)
to determine if the script invocation failed, and if does fail we'll =echo= our error message.

#+caption:
#+name: configure_no_texinfo
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 | tail -5
  [[ ${PIPESTATUS[0]} -ne 0 ]] && echo Configure failed!
#+end_src

#+RESULTS[00671bba10d837ec06b27855640085d0d766d6f6]: configure_no_texinfo
#+begin_example
checking for 'find' args to delete a file... -delete
checking for brew... no
configure: error: You do not seem to have makeinfo >= 4.13, and your
source tree does not seem to have pre-built manuals in the 'info' directory.
Please install a suitable version of makeinfo.
Configure failed!
#+end_example

Oops, looks like we don't have the =makeinfo= tool installed. GNU Texinfo is the official documentation format of the
GNU project, and the Emacs build process uses =makeinfo= to build the =info= files for the wealth of documentation that
comes with it. By default on {{{pr(osver)}}}, none of the GNU Texinfo tools (like =makeinfo=) are installed, so let's
install them now.

#+caption: Install the GNU Texinfo tools
#+name: install_texinfo
#+begin_src bash
  <<get_prop("install")>> texinfo >/dev/null 2>&1
#+end_src

#+RESULTS[96772795ca32600810d841be66ccf99b0c5a6a36]: install_texinfo
<<determine_package_name>>
Now you might be asking yourself, "How did you know that the =makeinfo= tool is in the =texinfo= package?". That's a
good question! It's not immediately obvious that =makeinfo= is part of the GNU Texinfo system, and without that key bit
of information it'd be a real struggle to figure out which package to install in order to satisfy the missing
dependency.

*** Determining the package name for a given a filename              :debian:
Luckily there's a handy tool called =apt-file= that you can install that searches for packages that contain specific
filenames.

#+caption: Install apt-file and update its database
#+name: install_apt_file
#+begin_src bash
  sudo apt-get install -qq apt-file >/dev/null 2>&1
  sudo apt-file update >/dev/null 2>&1
#+end_src

#+RESULTS[8bc0f5f65c0314817e5832f02240290e58504a41]: install_apt_file
Now that it's installed, you can see it in action. To cut down on false positives, we're running =apt-file search= with
the =--regex= option to use a regular expression to search for files that end in =makeinfo=.

#+caption: Use apt-file to preform a regex search on makeinfo
#+name: apt_file_search
#+begin_src bash
  apt-file search --regex makeinfo$
#+end_src

#+RESULTS[63f7fc196e5e1415a1831f69340ae4ff2d3f8250]: apt_file_search
#+begin_example
libear: /usr/lib/x86_64-linux-gnu/bear/wrapper.d/makeinfo
texinfo: /usr/bin/makeinfo
#+end_example

There you have it: =/usr/bin/makeinfo= is very likely the binary we're looking for, and we can see it comes from the
=texinfo= package!

*** Determining the package name for a given filename                :redhat:
Luckily the =dnf= tool has a =provides= sub-command that you can use to determine which package a given file exists
in. We can use this to determine which package that the =makeinfo= command is in.

#+caption: Use "dnf provides" to find the package containing makeinfo
#+name: rh_dnf_provides
#+begin_src bash :cache yes
  dnf provides makeinfo | head -5
#+end_src

#+RESULTS[80cc75d1d039e60d9821c0272d9981df486cb660]: rh_dnf_provides
#+begin_example
Last metadata expiration check: 1:06:03 ago on Sun 22 Oct 2023 12:13:31 AM PDT.
texinfo-7.0.2-2.fc38.aarch64 : Tools needed to create Texinfo format documentation files
Repo        : @System
Matched from:
Filename    : /usr/bin/makeinfo
#+end_example

There you have it: from the  output above, you can see the file =/usr/bin/makeinfo= is part of the texinfo package!

** Installing the GNU TLS Library
Let's run =./configure= yet again and see what happens! Anticipating more errors, we'll run it much the same way as last
time.

#+caption:
#+name: configure_no_gnutls
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 | tail -6
  [[ ${PIPESTATUS[0]} -ne 0 ]] && echo Configure failed!
#+end_src

#+RESULTS[aa8fc505a78fd8220e5292a49a112eac9bb3cd63]: configure_no_gnutls
#+begin_example
configure: error: The following required libraries were not found:
     gnutls
Maybe some development libraries/packages are missing?
To build anyway, give:
     --with-gnutls=ifavailable
as options to configure.
Configure failed!
#+end_example

Oops, looks like we don't have the GnuTLS library installed. The GNU Transport Layer Security library is the GNU
implementation of the SSL and TLS protocols, used for secure communication on the Internet. It's how (for example) Emacs
communicates with package archives like GNU ELPA in a secure manner. As per usual, when we hit a snag like this, we'll
install the necessary package to resolve the dependency.

#+caption: Install the the GnuTLS library
#+name: install_gnutls
#+begin_src bash
  <<get_prop("install")>> <<get_prop("gnutls")>> >/dev/null 2>&1
#+end_src

#+RESULTS[401e2733259a294b3c15c1f1e49122e558af0356]: install_gnutls

With libraries, it's helpful to know the traditional UNIX conventions of how they're named. For example, if you had a
library called =foo=, there would be a file somewhere in the filesystem named =libfoo.so= which is the =foo= library in
the /shared object/ format, and likely another file named =libfoo.a= which is the same library the the /archive/
format. Armed with this knowledge, you can use the techniques we discussed in section [[determine_package_name]] to
determine that the GnuTLS library is part of the {{{p(gnutls)}}} package.

** Installing the ncurses library

Here we go again: another run of the =configure= program to learn what our next missing dependency is!

#+caption:
#+name: configure_no_ncurses
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 | tail -6
  [[ ${PIPESTATUS[0]} -ne 0 ]] && echo Configure failed!
#+end_src

#+RESULTS[aa8fc505a78fd8220e5292a49a112eac9bb3cd63]: configure_no_ncurses
#+begin_example
configure: error: The required function 'tputs' was not found in any library.
The following libraries were tried (in order):
  libtinfo, libncurses, libterminfo, libcurses, libtermcap
Please try installing whichever of these libraries is most appropriate
for your system, together with its header files.
For example, a libncurses-dev(el) or similar package.
Configure failed!
#+end_example

Oops, looks like we don't have the =ncurses= library installed. =ncurses= is a terminal control library for Unix-like
systems that allows you to do fancy terminal tricks required by sophisticated TUI applications like Emacs. The original
library was named =curses= which is a bit of a pun on the term "cursor", which is something the library lets you move
around in an terminal-independent fashion. Today we'll be installing =ncurses=, which is the "new" version of the
library. We're using the term "new" loosely here,  as =ncurses= was originally released around 30 years ago.

#+caption: Install the the ncurses library
#+name: install_ncurses
#+begin_src bash
  <<get_prop("install")>> <<get_prop("ncurses")>> >/dev/null 2>&1
#+end_src

#+RESULTS[c681859aa57a97d538d22dfbc05c1c446e66513e]: install_ncurses

** Finally, a minimal configuration

I'm confident that we've worked out all the dependency issues, and now we can successfully configure a minimal version
of Emacs. The question is, how minimal? What features are we getting and what features aren't we getting? Let's change
our arguments to to =configure= slightly to find out. First we'll replace =tail= with a regular-expression =grep=
command to search for two spaces at the start of a line. This helps us filter out much of the noise that the
=./configure= script generates. Towards the end of a successful run of the script, it outputs a section prepended with
two spaces that provides important details of how Emacs is to be built. It's mostly which libraries are found and
used. If certain libraries aren't found, then certain features are disabled. For example, if the X Windows libraries
aren't found, then Emacs will only run in TUI mode.

We'll also flip the logic with regard to the =$PIPESTATUS= array, and we'll print a message on success rather than on
failure.

#+caption:
#+name: configure_final
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 | grep -E '^  '
  [[ ${PIPESTATUS[0]} -eq 0 ]] && echo Configure succeeded!
#+end_src

#+RESULTS[bac57fcab0fb9aec764708372bb6fd0754c703bf]: configure_final
#+begin_example
  Where should the build process find the source code?    .
  What compiler should emacs be built with?               gcc -g3 -O2
  Should Emacs use the GNU version of malloc?             no
    (The GNU allocators don't work with this system configuration.)
  Should Emacs use a relocating allocator for buffers?    no
  Should Emacs use mmap(2) for buffer allocation?         no
  What window system should Emacs use?                    none
  What toolkit should Emacs use?                          none
  Where do we find X Windows header files?                NONE
  Where do we find X Windows libraries?                   NONE
  Does Emacs use -lXaw3d?                                 no
  Does Emacs use -lXpm?                                   no
  Does Emacs use -ljpeg?                                  no
  Does Emacs use -ltiff?                                  no
  Does Emacs use a gif library?                           no 
  Does Emacs use a png library?                           no 
  Does Emacs use -lrsvg-2?                                no
  Does Emacs use -lwebp?                                  no
  Does Emacs use -lsqlite3?                               no
  Does Emacs use cairo?                                   no
  Does Emacs use -llcms2?                                 no
  Does Emacs use imagemagick?                             no
  Does Emacs use native APIs for images?                  no
  Does Emacs support sound?                               yes
  Does Emacs use -lgpm?                                   no
  Does Emacs use -ldbus?                                  no
  Does Emacs use -lgconf?                                 no
  Does Emacs use GSettings?                               no
  Does Emacs use a file notification library?             yes -lglibc (inotify)
  Does Emacs use access control lists?                    no
  Does Emacs use -lselinux?                               no
  Does Emacs use -lgnutls?                                yes
  Does Emacs use -lxml2?                                  no
  Does Emacs use -lfreetype?                              no
  Does Emacs use HarfBuzz?                                no
  Does Emacs use -lm17n-flt?                              no
  Does Emacs use -lotf?                                   no
  Does Emacs use -lxft?                                   no
  Does Emacs use -lsystemd?                               no
  Does Emacs use -ljansson?                               no
  Does Emacs use -ltree-sitter?                           no
  Does Emacs use the GMP library?                         yes
  Does Emacs directly use zlib?                           no
  Does Emacs have dynamic modules support?                yes
  Does Emacs use toolkit scroll bars?                     no
  Does Emacs support Xwidgets?                            no
  Does Emacs have threading support in lisp?              yes
  Does Emacs support the portable dumper?                 yes
  Does Emacs support legacy unexec dumping?               no
  Which dumping strategy does Emacs use?                  pdumper
  Does Emacs have native lisp compiler?                   no
  Does Emacs use version 2 of the X Input Extension?      no
  Does Emacs generate a smaller-size Japanese dictionary? no
Configure succeeded!
#+end_example

As you can see, quite a lot of libraries are not found, and this is indeed going to be a bare-bones build of Emacs! The
process now, for the adventurous reader who wants to build a much more feature complete version of Emacs, is to research
and install missing libraries until the list shown above has a lot more lines that end in 'yes'. Part of the fun is
researching what the various libraries are and how Emacs uses them. For example, did you know that =gconf= and
=gsettings= are two different ways of configuring Gnome applications, and if you install the correct libraries you can
build a version of Emacs that allows you to make certain configuration changes using /both/ methods? Crazy!

I'd be remiss if I didn't mention that the =./configure= script has a =--help= option, and there are many options that
begin with =--with-<something>= that allow you to explicitly build in certain features. There's a wealth of features and
options to explore here!  Here's a taste:

#+caption: Run configure with the help option and only display the --with-x options
#+name: configure_help
#+begin_src bash
  ./configure --help | grep -E '^  --with-'
#+end_src

#+RESULTS[78d8975af5b1234bd313f8287264e31598cce0ba]: configure_help
#+begin_example
  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
  --with-mailutils        rely on GNU Mailutils, so that the --without-pop
  --with-pop              Support POP mail retrieval if Emacs movemail is used
  --with-kerberos         support Kerberos-authenticated POP
  --with-kerberos5        support Kerberos version 5 authenticated POP
  --with-hesiod           support Hesiod to get the POP server host
  --with-mail-unlink      unlink, rather than empty, mail spool after reading
  --with-mailhost=HOSTNAME
  --with-sound=VALUE      compile with sound support (VALUE one of: yes, alsa,
  --with-pdumper=VALUE    enable pdumper support unconditionally ('yes', 'no',
  --with-unexec=VALUE     enable unexec support unconditionally ('yes', 'no',
  --with-dumping=VALUE    kind of dumping to use for initial Emacs build
  --with-x-toolkit=KIT    use an X toolkit (KIT one of: yes or gtk, gtk2,
  --with-wide-int         prefer wide Emacs integers (typically 62-bit); on
  --with-cairo-xcb        use XCB surfaces for Cairo support
  --with-imagemagick      compile with ImageMagick image support
  --with-json             compile with native JSON support
  --with-tree-sitter      compile with tree-sitter
  --with-ns               use Nextstep (macOS Cocoa or GNUstep) windowing
  --with-w32              use native MS Windows GUI in a Cygwin build
  --with-pgtk             use GTK to support window systems other than X
  --with-gconf            compile with Gconf support (Gsettings replaces this)
  --with-cygwin32-native-compilation
  --with-small-ja-dic     generate a smaller-size Japanese dictionary
  --with-file-notification=LIB
  --with-xwidgets         enable use of xwidgets in Emacs buffers (requires
  --with-be-app           enable use of Haiku's Application Kit as a window
  --with-be-cairo         enable use of cairo under Haiku's Application Kit
  --with-gameuser=USER_OR_GROUP
  --with-gnustep-conf=FILENAME
  --with-native-compilation[=TYPE]
  --with-x                use the X Window System
#+end_example

When I build Emacs 29 I often include newer, sexy options like =--with-pgtk=, =--with-tree-sitter=, and of course
=--with-native-compilation= which has been a /killer/ feature since Emacs 28. Each of these options comes with its own
trade-offs and required dependencies you'll have to track down and install, so do your homework!

* Building Emacs

Now that we've successfully configured a minimal version of Emacs, we can actually build it. At this point, it's just
a matter of running =make && make install= and waiting. That said, there are a few tricks to make things go faster. We
can provide the =-j= flag to GNU Make to specify the number of jobs (or commands) to run simultaneously, letting us take
advantage of all the CPU cores we might have sitting idle. The =nproc= command returns the number of CPU processing
units that are available, and we can use this in conjunction with the =-j= flags to unleash all our processing power on
this build! If we set the =MAKEFLAGS= environment variable prior to running =make=, we can ensure that our flags are
passed along every time =make= recursively calls itself during the process.

We'll redirect =stdout= and =stderr= to =/dev/null= as per usual to avoid the copious output produced by =make=, and
we'll also echo a message if the whole process completes successfully.

#+caption: Run make using all our available cores
#+name: make
#+begin_src bash
  MAKEFLAGS=-j$(nproc) make > /dev/null 2>&1 && echo Make ran successfully!
#+end_src

#+RESULTS[d2dac4260eb378d08623336725f8af8d9f02063b]: make
#+begin_example
Make ran successfully!
#+end_example

** Examining the Emacs binary
Now that we've successfully built the binary, let's find where it lives on the filesystem. To that end, we'll use the
=find= command with the =-type f= predicate to indicate that we just want to find regular files (as opposed to
directories, sockets, or other unusual filesystem objects).

#+caption: Find files named emacs
#+name: find_emacs
#+begin_src bash
  find . -type f -name emacs
#+end_src

#+RESULTS[17991de67b894279babacfe7e9507d3612210363]: find_emacs
#+begin_example
./src/emacs
#+end_example

That's easy enough. Now let's run the =file= tool on it to see what kind of file Linux thinks it is. Also, because the
output can run long, we'll pipe the it into =fmt -w 80= to wrap the output at 80 columns.

#+caption: Run the file command on the Emacs binary and wrap output to 80 characters
#+name: file_emacs
#+begin_src bash
  file <<strip(find_emacs())>> | fmt -w 80
#+end_src

#+RESULTS[e9ac48e91dc6d66b022591ea76afb0ab4c4ca878]: file_emacs
#+begin_example
./src/emacs: ELF 64-bit LSB pie executable, ARM aarch64, version 1
(SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1,
BuildID[sha1]=5c6926b06d5083f898be19f5e62c35ba94276742, for GNU/Linux 3.7.0,
with debug_info, not stripped
#+end_example

That definitely looks like a binary!

** Evaluate some Emacs Lisp code using the binary
Now that we've validated that {{{s(find_emacs}}} is actually a binary, let's see if we can get it to evaluate some Emacs
lisp code! We'll run the binary with the =-batch= and =-eval= options to have Emacs evaluate some code and then
immediately exit. The code we'll have it evaluate prints the value of the =system-configuration-options= variable to
=stdout= using the =princ= function, which stands for "print characters" and is for human-readable output, as opposed to
output meant to be read by Lisp itself.

#+caption: Evaluate some Emacs Lisp code using -batch and -eval
#+name: run_elisp
#+begin_src bash
  <<strip(find_emacs())>> -batch -eval '(princ system-configuration-options)'
#+end_src

#+RESULTS[704062010b1fe50d304a43cfe4cd11709e0f1b6c]: run_elisp
#+begin_example
--prefix=/home/mikeh/emacs-29.1.90
#+end_example

Good news, looks like it's working!

* Installing Emacs

Now that everything is built, and we've validated we have a working binary, we can now install it! No tricks here; we
just run =make install= and wait!

#+caption: Install Emacs!
#+name: make_install
#+begin_src bash
  make install >/dev/null 2>&1 && echo Make ran successfully!
#+end_src

#+RESULTS[d60e33654d849aca2d9152d4e45e8b37175db277]: make_install
#+begin_example
Make ran successfully!
#+end_example

** What did we install?

Let's take a look and see what got installed in our {{{s(tag_dir)}}} directory. We'll use the =du= command to get an
idea of just how much stuff got installed into our =$HOME= directory. We'll also pipe the output into =sort -rh= to
reverse sort the lines using the "human numeric sort", so that it groks the difference between megabytes and kilobytes.

#+caption: Have du give us a summary of directory sizes in human-readable format
#+name: run_du
#+begin_src bash
  du -hs <<tag_dir()>>/* | sort -rh
#+end_src

#+RESULTS[0174c5134c839087e3da1bc0594e1c2ec49b200c]: run_du
#+begin_example
108M	/home/mikeh/emacs-29.1.90/share
22M	/home/mikeh/emacs-29.1.90/bin
12M	/home/mikeh/emacs-29.1.90/libexec
36K	/home/mikeh/emacs-29.1.90/include
16K	/home/mikeh/emacs-29.1.90/lib
#+end_example

It looks like the =share= directory is the biggest, clocking in at call_lsplit(run_du)! That directory contains lots of
ancillary files, such as icons, images, text files like the =NEWS= and =JOKES= files, themes, tutorials, a mountain of
compiled and source Elisp code, and documentation like refcards, info files, and manual pages.

** What's in the bin directory?

#+caption: Run ls with the long and human-readable size options
#+name: bin_dir
#+begin_src bash
  ls -lh <<tag_dir()>>/bin/*
#+end_src

#+RESULTS[570d0bff0160ec0c3dc4cf090eb721fbca00c573]: bin_dir
#+begin_example
-rwxr-xr-x 1 mikeh mikeh 446K Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/ctags
-rwxr-xr-x 1 mikeh mikeh 196K Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/ebrowse
lrwxrwxrwx 1 mikeh mikeh   13 Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/emacs -> emacs-29.1.90
-rwxr-xr-x 1 mikeh mikeh  21M Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/emacs-29.1.90
-rwxr-xr-x 1 mikeh mikeh 233K Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/emacsclient
-rwxr-xr-x 1 mikeh mikeh 435K Oct 25 18:02 /home/mikeh/emacs-29.1.90/bin/etags
#+end_example

Emacs helpfully comes with the main and client Emacs binaries, and various programs from generating tags, as well as a
program for browsing C++ class hierarchies. I think our work here is done!

* Final Thoughts

I hope you've enjoyed reading this document! Hopefully it's also given you the basics of building Emacs on
{{{pr(osver)}}} systems, and the confidence to explore creating your own perfect build of GNU Emacs!

* Set some Emacs Variables and Run some Elisp Code                 :noexport:
<<emacs variables>>
In this section, we're going to set up some buffer local variables and run some code. This will allow this literate
document to run code on your system. Most of these changes are in service to generating a nice PDF file using LaTeX.

In summary:

- Text should wrap at 120 columns.
- We should be able to run shell and emacs-lisp code blocks.
- Elisp code blocks should be evaluated without confirmation.
- Properties defined in one heading should be inherited by all other headings.
- Executing a source block should always produce a =begin_example= block.
- We should use "xelatex" as the latex compiler.
- We should run the latex to pdf process using "latexmk" with some specific arguments.
- Hyperlinks should not have janky red boxes around them (colorlinks=true).
- We need to add the "titletoc" package to the default latex packages list, but before hyperref.
- Source code blocks should be formatted in LaTeX using the "listings" package.
- All source code blocks should have a simple box framing them.
- Execute an Elisp source block called "startup": the buffer should remain unmodified, and code heading folded.

# Local Variables:
# fill-column: 120
# eval: (org-babel-do-load-languages 'org-babel-load-languages '((shell . t) (emacs-lisp . t)))
# org-confirm-babel-evaluate: (lambda (lang body) (not (or (string= lang "elisp") (string= lang "emacs-lisp"))))
# org-use-property-inheritance: t
# org-babel-min-lines-for-block-output: 0
# org-latex-compiler: "xelatex"
# org-latex-pdf-process: ("latexmk -f -pdf -%latex -8bit -shell-escape -interaction=nonstopmode -output-directory=%o %f")
# org-latex-hyperref-template: "\\hypersetup{\n pdfauthor={%a},\n pdftitle={%t},\n colorlinks=true}\n")
# org-latex-default-packages-alist: (("AUTO" "inputenc" t ("pdflatex"))
#                                    ("T1" "fontenc" t ("pdflatex"))
#                                    ("" "graphicx" t)
#                                    ("" "longtable" nil)
#                                    ("" "wrapfig" nil)
#                                    ("" "rotating" nil)
#                                    ("normalem" "ulem" t)
#                                    ("" "amsmath" t)
#                                    ("" "amssymb" t)
#                                    ("" "capt-of" nil)
#                                    ("" "titletoc" nil)
#                                    ("" "hyperref" nil))
# org-latex-listings: t
# org-latex-listings-options: (("frame" "single"))
# eval: (progn
#         (org-babel-goto-named-src-block "startup")
#         (org-babel-execute-src-block)
#         (set-buffer-modified-p nil)
#         (outline-hide-subtree))
# End:
