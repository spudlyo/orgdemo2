#+TITLE: Building Emacs from Source
#+AUTHOR: Mike Hamrick
#+EMAIL: mikeh@muppetlabs.com
#+OPTIONS: ^:nil date:t email:t num:2 tags:nil toc:nil
#+STARTUP: content
#+SETUPFILE: latex.setup
#+INCLUDE: macros.setup
#+EXCLUDE_TAGS: noexport redhat

#+begin_export latex
  \begin{center}
     \includesvg[width=10cm]{logo.svg}
  \end{center}
  \clearpage \tableofcontents \clearpage
#+end_export

* README                                                           :noexport:
:PROPERTIES:
:VISIBILITY: all
:END:
This file is a literate Org-mode document. It is intended to be "run" by GNU Emacs 27.1 or higher. This document can
execute =bash= shell code in order to demonstrate how to create install packages and build Emacs. Out of the
box however, all exported =bash= code blocks include cached results from a previous run. This means no bash code blocks
will be executed on your system. If Emacs ever asks you if you want to execute a =bash= source code block, it means
something is no longer cached and you should be wary of saying "yes" unless you know what you're doing.

This Org-mode document you're currently viewing can be seen as "source code" that produces a document that explains how
to build Emacs from scratch on both RedHat and Debian based systems. The hope is that this Org-mode source code is
useful for understanding how to create nice-looking literate Org-mode documents. The resulting document that it produces
I hope some people might find interesting, but ultimately it's not important for the purposes of understanding how
Org-mode works.

** Operating System Prerequisites
This document is intended to be "run" on a GNU/Linux system. It has been tested on both RedHat based systems (Fedora
release 38 server edition) and Debian based systems (Ubuntu Server 22.04).

** Chosing which version of the document to export
The doccument will will differ slightly depending on which version of the document you chose to export. By default, if
this document is not altered in any way, you will get the Debian/Ubuntu version of the document. If you wish to export
the RedHat/Fedora version of the document you will need to:

- Change the "#+EXCLUDE_TAGS:" line at the top of the document to "noexport debian"
- Change the ":prefix:" property in section [[constants]] to "rh_"

*** Using the 'sudo' command
Many of the =bash= code blocks in this document use the =sudo= command in order to execute shell commands as a privileged
user. By default, =sudo= will prompt you for a password, which will cause issues when running the commands in this
document, since we're not running in an interactive mode. In order for your local user to run privileged commands
/without/ a password, you'll need to make a change to the =/etc/sudoers= file using the =sudo visudo= command, which will fire
up =$EDITOR= for you to edit =/etc/sudoers=.

You should see a section in the file that allows users of a specific group (in this case the =sudo= group) to execute any
command. On RedHat based GNU/Linux systems the group is called =wheel= rather than =sudo=.

#+CAPTION: Relevant section from /etc/sudoers on Ubuntu
#+begin_example
# Allow members of group sudo to execute any command
%sudo   ALL=(ALL:ALL) ALL
#+end_example

When you edit it, you'll want to change it to look like this:

#+CAPTION: Updated section from /etc/sudoers on Ubuntu
#+begin_example
# Allow members of group sudo to execute any command
%sudo   ALL=(ALL) NOPASSWD: ALL
#+end_example

** Emacs Prerequisites
This document has been tested on Emacs 27.1, Emacs 28.3, and Emacs 29.1. It may work on earlier versions of Emacs if
you've installed Org mode version 9.3 or above. You should be able to export this document to Plain Text or PDF formats
without installing any additional Emacs packages, it should work with Vanilla Emacs. You also don't need the GUI version
of Emacs, it should work fine in the Terminal.

On Ubuntu 22.04 you can install Emacs 29.1 by running: =sudo snap install emacs --classic=, on Fedora 38 you can install
Emacs using =sudo dnf install emacs-nox=. Ideally you should be viewing this document inside GNU Emacs.

** LaTeX Prerequisites
If you want to export this document to LaTeX or PDF you'll need to install some some additional OS packages.

| Software       | Debian Package       | RedHat Package       |
|----------------+----------------------+----------------------|
| TeX Live       | texlive-latex-extra  | texlive-latex        |
| xelatex        | texlive-xetex        | texlive-xetex        |
| pdflatex       | texlive-extra-utils  | texlive-latex        |
| latexmk        | latexmk              | latexmk              |
| inkscape       | inkscape             | inkscape             |
| JetBrains Mono | fonts-jetbrains-mono | jetbrains-mono-fonts |
| Inter          | fonts-inter          | rsms-inter-fonts     |

If you can run 'sudo' without needing a password you can hit =C-c C-c= on the block below to install the necessary
Debian packages to generate LaTeX PDF output. The block below that is for RedHat based systems.

*NOTE:* This can take several minutes to run, during which time Emacs may appear to be locked up as this work is /not/ done
asynchronously. This is around 1.5GB of packages, so make sure you have the space available.

#+caption: Install LaTeX Prerequisites on Debian based systems
#+name: deb_install_latex
#+begin_src bash :eval never-export :results output replace
  sudo apt-get install -qq \
       texlive-latex-extra \
       texlive-extra-utils \
       texlive-xetex \
       latexmk \
       inkscape \
       fonts-jetbrains-mono \
       fonts-inter
#+end_src

#+caption: Install LaTeX Prerequisites on RedHat based systems
#+name: rh_install_latex
#+begin_src bash :eval never-export :results output replace
  sudo dnf install -y \
       texlive-latex \
       texlive-xetex \
       texlive-wrapfig \
       texlive-ulem \
       texlive-capt-of \
       texlive-svg \
       texlive-trimspaces \
       texlive-parskip \
       latexmk \
       inkscape \
       jetbrains-mono-fonts \
       texlive-inter
#+end_src

** Executing the code found in this document
<<executing code>>
If you do want to actually execute the code in this document, you have a couple of options. You can navigate to the [[main
document]] and manually press =C-c C-c= on each code block. This will require you to invalidate the cache first, which you
can do by modifying the value of the checksum on the =+RESULTS[checksum]:= block. I like this approach because it gives you
precise control of when the blocks are executed, and lets you observe each result before moving to the next block.

Alternately can change the default header arg from =:cache yes= to =:cache no= in the [[main document]]. Once you do this,
when you export the document it should run all the source code blocks. Annoyingly it will prompt you for confirmation on
each =bash= code block. If you'd like to change this, you can hit =C-c C-c= on the block below which will cause Org-mode
to never confirm the execution of any source block.

# You know what you're doing, right? Right!?
#+name: no_babel_confirm
#+begin_src elisp :eval never-export
(setq org-confirm-babel-evaluate nil)
#+end_src

*NOTE*: Building Emacs can take 10-15 minutes or more on a slow machine. This means Emacs can be spinning its wheels for a
while during the export process while it cranks through the source blocks in the document. This is not asynchronous, and
Emacs will appear to be locked up during this time.

* Properties as Constants                                          :noexport:
:PROPERTIES:
:prefix: deb_
:rh_user: a Fedora 38 user
:deb_user: an Ubuntu 22.04 user
:deb_osver: Ubuntu Server 22.04
:rh_osver: Fedora Server 38
:rh_install: sudo dnf install -y
:deb_install: sudo apt-get install -qq
:END:
<<constants>>
The properties above define all the constants we're using throughout this document. By default, when you
run this document it will describe how to build GNU Emacs under a Debian based system. In order to build the
RedHat/Debian version of the document you must:

- Change the "#+EXCLUDE_TAGS:" line at the top of the document to "noexport debian"
- Change the ":prefix:" property above to "rh_"

* Code                                                             :noexport:
What follows is code that will be used throughout the document.

#+name: lsplit
#+begin_src elisp :results value :exports none :var line="foo bar\nbaz" :cache yes
(car (split-string line))
#+end_src

#+name: get_prop
#+begin_src elisp :results value :exports none :var prop="test"
(let ((ret (org-property-values prop))
      (prefix (org-property-values "prefix")))
  (if ret
      (car ret)
    (when prefix
      (car (org-property-values (concat (car prefix) prop))))))
#+end_src

#+name: strip
#+begin_src elisp :results value raw :exports none :var line="  foo  "
(string-trim line)
#+end_src

The following function is run when the document is loaded by Emacs. You have to OK this first. Most of what this code
does is make it so every =#+begin_example= and =#+end_example= block is rendered in LaTeX with a box around it. It's a lot
of effort for pretty boxes, but it's worth it. Also, if you're not using a custom Emacs theme I load the wonderful
=leuven= theme which comes with Emacs and makes Org documents look amazing. Sorry, not sorry.

#+NAME: startup
#+begin_src emacs-lisp :eval never-export :cache no :exports none
(require 'ox)

(if (null custom-enabled-themes)
    (load-theme 'leuven))

(defun my-latex-export-example-blocks (text backend info)
  "Export example blocks as smallbox env."
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      ;; replace verbatim env with smallbox
      (goto-char (point-min))
      (replace-string "\\begin{verbatim}" "\\begin{smallbox}")
      (replace-string "\\end{verbatim}" "\\end{smallbox}")
      (buffer-substring-no-properties (point-min) (point-max)))))

(make-local-variable 'org-export-filter-example-block-functions)
(add-to-list 'org-export-filter-example-block-functions
             'my-latex-export-example-blocks)
#+end_src

#+RESULTS: startup
| my-latex-export-example-blocks |

* Introduction
In this document we're going to demonstrate how you, {{{pr(user)}}}, can download and build the source code for GNU
Emacs. The goal is to walk through each step of the process, and explain things as we go. By default, most systems do
not have the necessary software components installed that are required to build GNU Emacs from source, so we'll also be
installing a lot of software on your computer. You'll need =sudo= access for this, and this document assumes that your
local user can run =sudo= without a password.

* Obtaining the Source Code
:PROPERTIES:
:header-args:       :noweb yes :exports both :cache yes
:header-args:bash:  :results output :dir ~/src/emacs
:END:
In this chapter I'll demonstrate how to download the Emacs source code using =git= and how to set your view of the code to
a specific tagged release of GNU Emacs.

** Installing Development Tools                                      :redhat:
By default, on the {{{pr(osver)}}} systems I tested on, the =git= tool is not installed, so the first thing we'll do is
install it, and some other development tools, using the =dnf= package management tool. Here we provide the =-y= option
so =dnf= doesn't ask us any questions, and we'll redirect STDOUT and STDERR to =/dev/null= to suppress the copious
amount of output that =dnf= spits out.

#+caption: Install the the Development Tools group of packages
#+name: rh_install_devtools
#+begin_src bash :dir ~/
  sudo dnf groupinstall -y --quiet "Development Tools" >/dev/null 2>&1
#+end_src

#+RESULTS[e47ce0ed8dba29e94038f234de67776a00b6ed1c]: rh_install_devtools

** Creating a source directory

The first thing we're going to want to do is to create a =~/src= directory beneath our home directory where all our
source code is going to live. We'll also change our current working directory to this directory. This helps keep things
tidy.

#+caption: Create and cd to our source directory
#+name: create_src_dir
#+begin_src bash :dir ~/
  mkdir -p ~/src; cd ~/src
#+end_src

#+RESULTS[1e510283b8ed64f004699221b06b8f48feef95c8]: create_src_dir

** Cloning the Repo
The next thing we'll want to do is clone the Emacs repository from /Savannah/, the software forge hosted by the Free
Software Foundation. This will be a full clone, complete with history, branches, and tags. It can take a few minutes to
complete. We'll provide the =--quiet= to =git= here to tell it not to report its progress to the screen.

#+caption: Clone the Emacs git repository from Savannah
#+name: clone_repo
#+begin_src bash :dir ~/src
  git clone --quiet https://git.savannah.gnu.org/git/emacs.git
  cd emacs
  #+end_src

  #+RESULTS[8c1c3caeaa94401e641350ecb1d16751ba044fdf]: clone_repo

** Digging into the tags
<<tags>>
Now that we've cloned the repository and set our current working directory to =~/src/emacs= let's take a look at some
tags. Emacs uses =git= tags to capture a point in the commit history that marks the release of a specific version. We can
run =git tag= to list all the available tags.

#+caption: How many tags are there?
#+name: num_tags
#+begin_src bash
  git tag | wc -l
  #+end_src

  #+RESULTS[bff0bbcb583233629cc6dabd0d6296379d4f1cc8]: num_tags
  #+begin_example
  183
  #+end_example

Wow {{{s(num_tags)}}} tags is a lot! We can narrow it down a bit by listing just the tags for Emacs 29. We'll use the
=git tag= command with the =--list= argument (using the shell wildcard syntax) as well as specifying the =--sort= option
to sort the tags by when the tag object in the database was created. We'll also specify the =-n= argument to print a
single line of annotation for the tag.

#+caption: List all the tags for Emacs version 29 sorted by date in descending tagged date order
#+name: sorted_tags
#+begin_src bash
  git tag --list 'emacs-29.*' --sort=-taggerdate -n1
#+end_src

#+RESULTS[fa306c1f9b3f73ea2220e75183509c97a622ef59]: sorted_tags
#+begin_example
emacs-29.1.90   Emacs 29.1.90 pretest
emacs-29.1      Emacs 29.1
emacs-29.1-rc1  Emacs 29.1 RC1
emacs-29.0.92   Emacs 29.0.92
emacs-29.0.91   Emacs 29.0.91 pretest
emacs-29.0.90   Emacs 29.0.90 pretest
#+end_example

#+name: emacs_tag
#+begin_src elisp :results value :exports none :var text=sorted_tags :cache yes
(with-temp-buffer
  (insert text) (beginning-of-buffer)
  (if (re-search-forward "\\(\\S-+\\)" nil t)
      (match-string 1)
    nil))
#+end_src

You might get a slightly different list when you run the command, but as of this writing, those are all the tagged
releases of Emacs 29. We'll be working with the version tagged {{{srv(emacs_tag)}}}, as that's the most recent.

** Creating the branch

Now that we've figured out which version tag we're going to want to use as the base for the version of Emacs that we're
building it's time to create a branch associated with that tag. Because we just cloned the repository, we're currently
on at the default branch.

#+caption: Ask git the name of our current branch
#+name: git_branch
#+begin_src bash
  git branch --show-current
#+end_src

#+RESULTS[853780933fd9180c73d0352492b67618b70a2c0c]: git_branch
#+begin_example
master
#+end_example

For our purposes, we don't want to build Emacs from the {{{srv(git_branch)}}} branch, instead let's create a branch that
points to the same commit as the {{{sr(emacs_tag)}}} tag that we identified in section [[tags]].

#+caption: Create a branch that points to a specific tag
#+name: create_branch
#+begin_src bash
  git checkout -b mybranch tags/<<emacs_tag()>> 2>&1
#+end_src

#+RESULTS[7f3bf7669e1efbb91dd5fd9cfedda00ebbecfe75]: create_branch
#+begin_example
Switched to a new branch 'mybranch'
#+end_example

We're good to go, we've created our branch at our tagged location and now we can start working on building the program!

* Creating the configure script
:PROPERTIES:
:header-args:       :noweb yes :exports both :cache yes
:header-args:bash:  :results output :dir ~/src/emacs
:END:
If you've ever built an old-school UNIX program from source, you've probably run a =./configure= script. This script
tests specific details about the environment it's running under in order to inform the build process how it should build
the code in a way that works with the operating system and libraries that exist on the system. Normally when building
trivial programs you can run an incantation like =./configure && make && make install= and you're good to go.

Let's see if we can find a suitable =./configure= script in the Emacs repository.

#+caption: Look for the configure script
#+name: where_configure
#+begin_src bash
  ls configure*
#+end_src

#+RESULTS[b55a980ceb18f9d71f4108e331b7f52e0340597b]: where_configure
#+begin_example
configure.ac
#+end_example

Looks like there isn't a =configure= script for us to run, so we'll have to generate one. The =configure= script is
generated using a tool called =autoconf= which is part of the GNU Build System, also known as Autotools. The =autoconf=
tool reads the =configure.ac= file we saw above and uses that to generate the =configure= script we'll ultimately run.

** Running the autogen.sh script
There is a script called =autogen.sh= that drives this process. It also modifies your cloned =.git/config= configuration
file as well as adding various hooks in =.git/hooks= that are suitable for Emacs development. Let's run the script, and
take a look at the first few lines of the output. We'll run =autogen.sh= with the =autoconf= argument to tell it to only
generate the =configure= script, and to leave our git configuration untouched.

#+caption: Run the autogen.sh script and show a bit of the output
#+name: autogen
#+begin_src bash
  ./autogen.sh autoconf | head -3
#+end_src

#+RESULTS[84927cdd35282147cb17b7f232466896e0b47b1c]: autogen
#+begin_example
Checking whether you have the necessary tools...
(Read INSTALL.REPO for more details on building Emacs)
Checking for autoconf (need at least version 2.65) ... missing
#+end_example

It looks like we're going to need to install =autoconf= before this is going to work for us.

*NOTE*: When we're installing software in this document, we'll often suppress the output like we do below by redirecting
STDERR and STDOUT to =/dev/null=. This is because the output is often quite long and irrelevant to the task at hand.

#+caption: Install autoconf and send the output to /dev/null
#+name: install_autoconf
#+begin_src bash
  <<get_prop("install")>> autoconf >/dev/null 2>&1
#+end_src

#+RESULTS[a8fa3622ef519098920b84ca052a3c03e4e8cf35]: install_autoconf

Now if we run the =autogen.sh= script again it should generate our =configure= script. This time we'll run it with the
=--no-check= argument because we've satisfied the autoconf dependency.

#+caption: Second time is a charm!
#+name: autogen_redux
#+begin_src bash
  ./autogen.sh --no-check autoconf
#+end_src

#+RESULTS[e9357d1355a2c1711fa9956e8a2c51ea486a4d03]: autogen_redux
#+begin_example
Building aclocal.m4 ...
Running 'autoreconf -fi -I m4' ...
You can now run './autogen.sh git'.
#+end_example

Now if we look for the =./configure= script again, it should be there!

#+caption: Look for the configure script again
#+name: where_configure_redux
#+begin_src bash
  stat --format "%s %n" ./configure
#+end_src

#+RESULTS[9d47e75f7838fcdaed93775e524b776ac8762b7c]: where_configure_redux
#+begin_example
1189578 ./configure
#+end_example

Wow, that is one huge shell script! When was the last time /you/ wrote a shell script that was
call_lsplit(where_configure_redux) bytes long?!

* Configuring the build process
:PROPERTIES:
:header-args:       :noweb yes :exports both :cache yes
:header-args:bash:  :results output :dir ~/src/emacs
:END:

#+name: tag_dir 
#+begin_src elisp :results value :exports none :var text=emacs_tag :cache yes
(concat "$HOME/" text)
#+end_src

In this section we're going to run the =./configure= script to kick off the configuration process. Initially we're not
going to specify which Emacs features we want to enable or get into any specifics of how it is built. Instead we're
going to see what it takes to build a minimal version of Emacs and what we get without tweaking the process.

** The prefix argument
One argument we /will/ be providing to the configure script will be the =--prefix= option. This tells the script the
base directory of where all the files should be installed. By default, when we later run =make install=, there will be a
number of directories created for both architecture dependent and indepent files like binaries, libaries, Emacs Lisp
code, and documentation. All of of these directories will be created beneath the directory we specify with our
=--prefix= argument. We'll use {{{s(tag_dir)}}} as our prefix directory, this way we can potentially build and
install multiple tagged versions of Emacs without conflict.

** Installing the build essential meta-package                       :debian:
Let's run =./configure= and see what happens. We'll provide our =--prefix= argument and we'll also redirect STDERR to
STDOUT so all the output goes to the same place. Finally we'll take advantage of the =bash= logical OR (=||=)
short-circuit to echo a message if =configure= returns a non-zero exit code.

#+caption: Our first attempt at running configure
#+name: configure_no_make
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 || echo Configure failed!
#+end_src

#+RESULTS[89c7b86937fc395d7e266087ed1a997523114667]: configure_no_make
#+begin_example
checking for xcrun... no
checking for GNU Make... 
configure: error: Building Emacs requires GNU Make, at least version 3.81.
If you have it installed under another name, configure with 'MAKE=...'.
For example, run './configure MAKE=gnu-make'.
Configure failed!
#+end_example

Oops, looks like we don't have GNU Make installed. By default on {{{pr(osver)}}} there aren't any development or build
tools installed. We can solve this problem by installing the =build-essential= meta-package, which installs a C/C++
compiler, GNU Make, and some libraries.

#+caption: Install the build-essential meta-package and send the output to /dev/null
#+name: install_build_essential
#+begin_src bash
  <<get_prop("install")>> build-essential >/dev/null 2>&1
#+end_src

#+RESULTS[e32146b70d108be5d1d3e1454bc6c98e526b0c1f]: install_build_essential

** Installing GNU Texinfo
Let's run =./configure= and see what happens. We'll provide our =--prefix= option and redirect STDERR to STDOUT so all
the output goes to the same place. Since the =configure= script can output quite a large volume of text to the terminal
we'll also pipe the output into =tail -5= to just see the last handful of lines. Finally we'll utilize the =bash= array
variable =PIPESTATUS= (which holds the exit statuses of each command executed in the most recent pipeline) to determine
if the script invocation failed, and if does fail we'll =echo= our error message.

#+caption: 
#+name: configure_no_texinfo
#+begin_src bash
  ./configure --prefix=<<tag_dir()>> 2>&1 | tail -5
  [[ ${PIPESTATUS[0]} -ne 0 ]] && echo Configure failed!
#+end_src

#+RESULTS[00671bba10d837ec06b27855640085d0d766d6f6]: configure_no_texinfo
#+begin_example
checking for 'find' args to delete a file... -delete
checking for brew... no
configure: error: You do not seem to have makeinfo >= 4.13, and your
source tree does not seem to have pre-built manuals in the 'info' directory.
Please install a suitable version of makeinfo. 
Configure failed!
#+end_example

Oops, looks like we don't have the =makeinfo= tool installed. GNU Texinfo is the official documentation format of the
GNU project, and the Emacs build processes uses =makeinfo= to build the =info= files for the wealth of documentation
that comes with it. By default on {{{pr(osver)}}} none of the GNU Texinfo tools (like =makeinfo=) are installed, so
let's install them now.

#+caption: Install the GNU Texinfo tools
#+name: install_texinfo
#+begin_src bash
  <<get_prop("install")>> texinfo >/dev/null 2>&1
#+end_src

#+RESULTS[96772795ca32600810d841be66ccf99b0c5a6a36]: install_texinfo

* Set some Emacs Variables and Run some Elisp Code                 :noexport:
<<emacs variables>>
In this section we're going to set up some buffer local variables and run some code. This will allow this literate
document to run code on your system. Most of these changes are in service to generating a nice PDF file using LaTeX.

In summary:

- Text should wrap at 120 columns
- We should be able to run shell and emacs-lisp code blocks
- Elisp code blocks should be evaluated without confirmation
- Properties defined in one heading should be inherited by all other headings
- Executing a source block should always produce a =begin_example= block
- We should use "xelatex" as the latex compiler
- We should run the latex to pdf process using 'latexmk' with some specific arguments
- Hyperlinks should not have janky red boxes around them (colorlinks=true)
- We need to add the "titletoc" package to the default latex packages list, but before hyperref
- Source code blocks should be formatted in LaTeX using the "listings" package
- All source code blocks should have a simple box framing them
- Execute a elisp source block called "startup", the code heading should remain folded

# Local Variables:
# fill-column: 120
# eval: (org-babel-do-load-languages 'org-babel-load-languages '((shell . t) (emacs-lisp . t)))
# org-confirm-babel-evaluate: (lambda (lang body) (not (or (string= lang "elisp") (string= lang "emacs-lisp"))))
# org-use-property-inheritance: t
# org-babel-min-lines-for-block-output: 0
# org-latex-compiler: "xelatex"
# org-latex-pdf-process: ("latexmk -f -pdf -%latex -8bit -shell-escape -interaction=nonstopmode -output-directory=%o %f")
# org-latex-hyperref-template: "\\hypersetup{\n pdfauthor={%a},\n pdftitle={%t},\n colorlinks=true}\n")
# org-latex-default-packages-alist: (("AUTO" "inputenc" t ("pdflatex"))
#                                    ("T1" "fontenc" t ("pdflatex"))
#                                    ("" "graphicx" t)
#                                    ("" "longtable" nil)
#                                    ("" "wrapfig" nil)
#                                    ("" "rotating" nil)
#                                    ("normalem" "ulem" t)
#                                    ("" "amsmath" t)
#                                    ("" "amssymb" t)
#                                    ("" "capt-of" nil)
#                                    ("" "titletoc" nil)
#                                    ("" "hyperref" nil))
# org-latex-listings: t
# org-latex-listings-options: (("frame" "single"))
# eval: (progn
#         (org-babel-goto-named-src-block "startup")
#         (org-babel-execute-src-block)
#         (set-buffer-modified-p nil)
#         (outline-hide-subtree))
# End:
